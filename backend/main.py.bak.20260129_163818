import asyncio
import os
import sys
import uuid
from pathlib import Path
from typing import AsyncGenerator, Optional

from fastapi import FastAPI, Query, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse

app = FastAPI(title="Jarvis Agent Bridge")

# CORS: allow frontend dev server (Vite default 5173)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173", "http://127.0.0.1:5173"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

PROJECT_ROOT = Path(__file__).resolve().parents[1]
LOCAL_AGENT = PROJECT_ROOT / "local_agent.py"

# 프로젝트 루트 venv의 Python으로 서브프로세스 실행 (local_agent.py 의존성 동일 환경)
def _venv_python() -> Path:
    if os.name == "nt":
        candidate = PROJECT_ROOT / ".venv" / "Scripts" / "python.exe"
    else:
        candidate = PROJECT_ROOT / ".venv" / "bin" / "python"
    return candidate if candidate.exists() else Path(sys.executable)


def _sse_data(data: str) -> bytes:
    """EventSource onmessage는 event가 없거나 event: message 일 때만 호출됨. data만 보냄."""
    return f"data: {data}\n\n".encode("utf-8")


# 세션: session_id -> 프로세스 + 락 (동일 세션 내 요청 직렬화)
class _Session:
    __slots__ = ("proc", "lock")

    def __init__(self, proc: asyncio.subprocess.Process):
        self.proc = proc
        self.lock = asyncio.Lock()


_sessions: dict[str, _Session] = {}


async def _close_session(session_id: str) -> None:
    if session_id not in _sessions:
        return
    sess = _sessions.pop(session_id)
    if sess.proc.returncode is None:
        sess.proc.terminate()
        try:
            await asyncio.wait_for(sess.proc.wait(), timeout=2)
        except Exception:
            sess.proc.kill()


async def _get_or_create_session(session_id: str) -> _Session:
    if session_id in _sessions:
        sess = _sessions[session_id]
        if sess.proc.returncode is not None:
            del _sessions[session_id]
        else:
            return sess

    py = str(_venv_python())
    env = os.environ.copy()
    env["PYTHONUNBUFFERED"] = "1"
    env["PYTHONPATH"] = str(PROJECT_ROOT) + (
        os.pathsep + env.get("PYTHONPATH", "") if env.get("PYTHONPATH") else ""
    )
    proc = await asyncio.create_subprocess_exec(
        py,
        "-u",
        str(LOCAL_AGENT),
        stdin=asyncio.subprocess.PIPE,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.STDOUT,
        cwd=str(PROJECT_ROOT),
        env=env,
    )
    sess = _Session(proc)
    _sessions[session_id] = sess
    return sess


async def _stream_until_marker(
    proc: asyncio.subprocess.Process,
    request: Request,
    marker: str,
) -> AsyncGenerator[bytes, None]:
    yield _sse_data("{\"type\":\"meta\",\"ok\":true}")

    if proc.stdout is None:
        yield _sse_data("{\"type\":\"done\",\"ok\":true,\"code\":0}")
        return

    while True:
        if await request.is_disconnected():
            break
        line = await proc.stdout.readline()
        if not line:
            break
        text = line.decode("utf-8", errors="replace").rstrip("\n")
        if marker in text or text.strip() == marker:
            break
        # CLI 프롬프트 "You>" 라인은 채팅 UI로 보내지 않음
        stripped = text.strip()
        if stripped in ("You>", "You> "):
            continue
        safe = text.replace("\\", "\\\\").replace('"', '\\"')
        yield _sse_data(f"{{\"type\":\"chunk\",\"text\":\"{safe}\"}}")

    yield _sse_data("{\"type\":\"done\",\"ok\":true,\"code\":0}")


@app.get("/api/agent/session/reset")
async def session_reset(
    session_id: str = Query("default", description="Session to close"),
):
    """해당 세션의 agent 프로세스를 종료합니다. 프론트에서 세션 초기화 시 호출."""
    await _close_session(session_id)
    return {"ok": True}


@app.get("/api/agent/stream")
async def agent_stream(
    request: Request,
    prompt: str = Query("", description="User prompt to send to local_agent.py"),
    workdir: Optional[str] = Query(None, description="Optional project workdir to set inside agent"),
    session_id: str = Query("default", description="Session id to reuse the same agent process"),
    reset: bool = Query(False, description="If true, close the session before this request"),
):
    if not LOCAL_AGENT.exists():
        return StreamingResponse(
            iter([_sse_data("{\"type\":\"error\",\"ok\":false,\"error\":\"local_agent.py not found\"}")]),
            media_type="text/event-stream",
        )

    if reset:
        await _close_session(session_id)

    sess = await _get_or_create_session(session_id)
    marker = f"__JARVIS_DONE__:{uuid.uuid4().hex}"

    async with sess.lock:
        assert sess.proc.stdin is not None
        if workdir:
            sess.proc.stdin.write(f"__JARVIS_WORKDIR__:{workdir}\n".encode("utf-8"))
            await sess.proc.stdin.drain()
        sess.proc.stdin.write((prompt + "\n").encode("utf-8"))
        sess.proc.stdin.write((marker + "\n").encode("utf-8"))
        await sess.proc.stdin.drain()

        return StreamingResponse(
            _stream_until_marker(sess.proc, request, marker),
            media_type="text/event-stream",
            headers={
                "Cache-Control": "no-cache, no-transform",
                "Connection": "keep-alive",
                "X-Accel-Buffering": "no",
            },
        )
